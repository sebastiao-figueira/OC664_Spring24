import numpy as np

# read-in field data
data = np.load("dataset_19971022_0700EST.mat")

# iterate over all gauges & assign arrays for different data types
u, p, x, y, zu, zp, zbed = [], [], [], [], [], [], []
for i in range(8):
    u.append(data['u'][:, i])  # cross-shore velocity (m/s, 2Hz)
    p.append(data['p'][:, i])  # water surface elevation (m, 2Hz) relative to zp
    x.append(data['x'][:, i])  # cross-shore position of sensors
    y.append(data['y'][:, i])  # alongshore position of sensors
    zu.append(data['zu'][:, i])  # vertical position for u-sensor
    zp.append(data['zp'][:, i])  # vertical position for p-sensor
    zbed.append(data['zbed'][:, i])  # vertical position of seabed (from sonar altimeter)

# create time array for 21504 points at 2Hz. 2Hz = .5s time step
t = np.arange(0, 21504 / 2, 0.5)

# concatentate "t" and "u" to associate time data with velocity data
for i in range(8):
    u[i] = np.column_stack((u[i], t))

# do zero up crossing analysis
all_waves = []

# iterate over each gauge's velocity data
for i in range(8):
    # find zero-up crossings for the current gauge's velocity data
    zero_upcrossings_indices = np.where((u[i][:-1, 0] <= 0) & (u[i][1:, 0] > 0))[0]

    # extract wave data for each zero-up crossing
    waves = []
    for j in range(len(zero_upcrossings_indices)):
        start_idx = zero_upcrossings_indices[j]
        if j < len(zero_upcrossings_indices) - 1:
            end_idx = zero_upcrossings_indices[j + 1]
        else:
            end_idx = u[i].shape[0]
        waves.append(u[i][start_idx:end_idx, :])
    
    # store extracted waves into "all_waves" list
    all_waves.append(waves)


# do zero down crossing analysis
zero_downcrossings = []

# iterate over each gauge's waves
for i in range(8):
    zero_downcrossings_gauge = []
    
    # iterate over each wave for each gauge
    for j in range(len(all_waves[i])):
        # extract the velocity and time data for each wave
        wave_data = all_waves[i][j]
        wave_velocity = wave_data[:, 0]
        wave_time = wave_data[:, 1]
        
        # find indices where velocity goes from positive to negative
        zero_downcrossing_indices = np.where((wave_velocity[:-1] > 0) & (wave_velocity[1:] <= 0))[0]
        
        # store the time values corresponding to velocity zero down crossings
        zero_downcrossings_gauge.append(wave_time[zero_downcrossing_indices])
    
    zero_downcrossings.append(zero_downcrossings_gauge)


# identify time associated with the velocity positive maxima for each wave
maxima_positive_velocity = []
maxima_positive_time = []

# iterate over each gauge's waves
for i in range(8):
    maxima_positive_velocity_gauge = np.zeros(len(all_waves[i]))
    maxima_positive_time_gauge = []

    # iterate over each wave for each gauge
    for j in range(len(all_waves[i])):
        # extract the velocity and time data for each wave
        wave_data = all_waves[i][j]
        wave_velocity = wave_data[:, 0]
        wave_time = wave_data[:, 1]

        # find the maximum velocity value within the wave
        max_velocity = np.max(wave_velocity)
        max_index = np.argmax(wave_velocity)

        # store the maximum velocity value as positive maxima
        maxima_positive_velocity_gauge[j] = max_velocity

        # store the time associated with the maximum velocity
        maxima_positive_time_gauge.append(wave_time[max_index])

    maxima_positive_velocity.append(maxima_positive_velocity_gauge)
    maxima_positive_time.append(maxima_positive_time_gauge)

# identify time associated with the velocity negative maxima for each wave
maxima_negative_velocity = []
maxima_negative_time = []

# iterate over each gauge's waves
for i in range(8):
    maxima_negative_velocity_gauge = np.zeros(len(all_waves[i]))
    maxima_negative_time_gauge = []

    # iterate over each wave for each gauge
    for j in range(len(all_waves[i])):
        # extract the velocity and time data for each wave
        wave_data = all_waves[i][j]
        wave_velocity = wave_data[:, 0]
        wave_time = wave_data[:, 1]

        # find the minimum velocity value within the wave
        min_velocity = np.min(wave_velocity)
        min_index = np.argmin(wave_velocity)

        # store the minimum velocity value as negative maxima
        maxima_negative_velocity_gauge[j] = min_velocity

        # store the time associated with the minimum velocity
        maxima_negative_time_gauge.append(wave_time[min_index])

    maxima_negative_velocity.append(maxima_negative_velocity_gauge)
    maxima_negative_time.append(maxima_negative_time_gauge)

# add the zero_downcrossings, maxima_negative_time, and maxima_positive_time
for i in range(8):
    for j in range(len(all_waves[i])):
        # assign zero_downcrossings if data exists
        if zero_downcrossings[i][j]:
            all_waves[i][j][0, 2] = zero_downcrossings[i][j][0]

        # assign maxima_positive_time if data exists
        if maxima_positive_time[i][j]:
            all_waves[i][j][0, 3] = maxima_positive_time[i][j]

        # Assign maxima_negative_time if data exists
        if maxima_negative_time[i][j]:
            all_waves[i][j][0, 4] = maxima_negative_time[i][j]

# parameterize T, T_c, T_t, T_cu, T_tu for each intra-wave
T, T_c, T_t, T_cu, T_tu = [], [], [], [], []

for i in range(8):
    T_gauge, T_c_gauge, T_t_gauge, T_cu_gauge, T_tu_gauge = [], [], [], [], []

    for j in range(len(all_waves[i])):
        T_gauge.append(all_waves[i][j][-1, 1] - all_waves[i][j][0, 1])
        T_c_gauge.append(all_waves[i][j][0, 2] - all_waves[i][j][0, 1])
        T_t_gauge.append(all_waves[i][j][-1, 1] - all_waves[i][j][0, 2])
        T_cu_gauge.append(all_waves[i][j][0, 3] - all_waves[i][j][0, 1])
        T_tu_gauge.append(abs(all_waves[i][j][0, 4] - all_waves[i][j][0, 2]))

    T.append(T_gauge)
    T_c.append(T_c_gauge)
    T_t.append(T_t_gauge)
    T_cu.append(T_cu_gauge)
    T_tu.append(T_tu_gauge)

# eqn (4): u_x = u_w + abs(u_delta) * cos(phi);
phi = 20  # obliquely incident current making angle with wave direction

# iterate to get time varying free-stream orbital velocity subscript, "w"
u_w = all_waves.copy()

# determine steady state current velocity, "u_delta"
u_delta = []
for i in range(8):
    u_delta_gauge = []
    for j in range(len(all_waves[i])):
        u_delta_gauge.append(np.mean(u_w[i][j][:, 0]) / np.cos(np.deg2rad(phi)))
    u_delta.append(u_delta_gauge)

# calculate u_x, time varying orbital velocity in x-direction
u_x = []
for i in range(8):
    u_x_gauge = []
    for j in range(len(all_waves[i])):
        u_x_gauge.append(u_w[i][j][:, 0] + np.abs(u_delta[i][j]) * np.cos(np.deg2rad(phi)))
    u_x.append(u_x_gauge)

# eqn (5): u_y = abs(u_delta) * sin(phi);
# calculate u_y, orbital velocity in y-direction
u_y = []
for i in range(8):
    u_y_gauge = []
    for j in range(len(all_waves[i])):
        u_y_gauge.append(np.abs(u_delta[i][j]) * np.sin(np.deg2rad(phi)))
    u_y.append(u_y_gauge)

# eqn (8): u_hat = sqrt((2 / T) * trapz((u_w) ^ 2));
u_hat = []
for i in range(8):
    u_hat_gauge = []
    for j in range(len(all_waves[i])):
        time_axis = np.linspace(0, T[i][j], len(u_w[i][j][:, 0]))
        u_squared_integral = np.trapz(u_w[i][j][:, 0] ** 2, time_axis)
        u_hat_gauge.append(np.sqrt((2 / T[i][j]) * u_squared_integral))
    u_hat.append(u_hat_gauge)

# eqn (8a) u_hat_c = sqrt((2 / T_c) * trapz((u_w) ^ 2));
u_hat_c = []
for i in range(8):
    u_hat_c_gauge = []
    for j in range(len(all_waves[i])):
        time_axis = np.linspace(0, T_c[i][j], len(u_w[i][j][:, 0]))
        u_squared_integral = np.trapz(u_w[i][j][:, 0] ** 2, time_axis)
        u_hat_c_gauge.append(np.sqrt((2 / T_c[i][j]) * u_squared_integral))
   
    u_hat_c.append(u_hat_c_gauge)

# eqn (8b) u_hat_t = sqrt((2 / T_t) * trapz((u_w) ^ 2));
u_hat_t = []
for i in range(8):
    u_hat_t_gauge = []
    for j in range(len(all_waves[i])):
        time_axis = np.linspace(0, T_t[i][j], len(u_w[i][j][:, 0]))
        u_squared_integral = np.trapz(u_w[i][j][:, 0] ** 2, time_axis)
        u_hat_t_gauge.append(np.sqrt((2 / T_t[i][j]) * u_squared_integral))
    u_hat_t.append(u_hat_t_gauge)

# eqn (9): a_hat = (u_hat * T) / (2 * pi);
a_hat = []
for i in range(8):
    a_hat_gauge = []
    for j in range(len(all_waves[i])):
        a_hat_gauge.append((u_hat[i][j] * T[i][j]) / (2 * np.pi))
    a_hat.append(a_hat_gauge)

# eqn (10): u_tilda_cr = (1 / 2) * sqrt(2) * u_hat_c;
u_tilda_cr = []
for i in range(8):
    u_tilda_cr_gauge = []
    for j in range(len(all_waves[i])):
        u_tilda_cr_gauge.append(0.5 * np.sqrt(2) * u_hat_c[i][j])
    u_tilda_cr.append(u_tilda_cr_gauge)

# eqn (11): u_tilda_tr = (1 / 2) * sqrt(2) * u_hat_t;
u_tilda_tr = []
for i in range(8):
    u_tilda_tr_gauge = []
    for j in range(len(all_waves[i])):
        u_tilda_tr_gauge.append(0.5 * np.sqrt(2) * u_hat_t[i][j])
    u_tilda_tr.append(u_tilda_tr_gauge)

# eqn (12)
# u_crx = u_tilda_cr + abs(u_delta * cos(phi));
# u_cry = abs(u_delta * sin(phi));
# u_vec_cr = [u_crx u_cry];
u_crx = []
u_cry = []
for i in range(8):
    u_crx_gauge = []
    u_cry_gauge = []
    for j in range(len(all_waves[i])):
        u_crx_gauge.append(u_tilda_cr[i][j] + np.abs(u_delta[i][j] * np.cos(np.deg2rad(phi))))
        u_cry_gauge.append(np.abs(u_delta[i][j] * np.sin(np.deg2rad(phi))))
    u_crx.append(u_crx_gauge)
    u_cry.append(u_cry_gauge)

# eqn (13)
# u_trx = -u_tilda_tr + abs(u_delta * cos(phi));
# u_try = abs(u_delta * sin(phi));
# u_vec_tr = [u_trx u_try];
u_trx = []
u_try = []
for i in range(8):
    u_trx_gauge = []
    u_try_gauge = []
    for j in range(len(all_waves[i])):
        u_trx_gauge.append(-u_tilda_tr[i][j] + np.abs(u_delta[i][j] * np.cos(np.deg2rad(phi))))
        u_try_gauge.append(np.abs(u_delta[i][j] * np.sin(np.deg2rad(phi))))
    u_trx.append(u_trx_gauge)
    u_try.append(u_try_gauge)

# eqn (celerity)
# iterate over all gauges to calculate mean eta (via pressure), then water depth
p_avg = np.mean(p, axis=0)
h = p_avg - zp

# call "wavelength" function at bottom of script to calculate the wavelength for each intra-wave
def wavelength(T, h):
    g = 9.81  # acceleration due to gravity in m/s^2
    L0 = (g * T ** 2) / (2 * np.pi)
    guess = L0
    L = (g * T ** 2) / (2 * np.pi) * np.tanh((2 * np.pi) * (h / guess))
    diff = np.abs(L - guess)

    while diff > 0.01:
        diff = np.abs(L - guess)
        guess = L + (0.5 * diff)
        L = (g * T ** 2) / (2 * np.pi) * np.tanh((2 * np.pi) * (h / guess))

    return L

L_new = []
for i in range(8):
    L_gauge = []
    for j in range(len(all_waves[i])):
        L_gauge.append(wavelength(T[i][j], h[i]))
    L_new.append(L_gauge)

# iterate to calculate c_w, celerity
c_w = []
for i in range(8):
    c_w_gauge = []
    for j in range(len(all_waves[i])):
        c_w_gauge.append(L_new[i][j] / T[i][j])
    c_w.append(c_w_gauge)





